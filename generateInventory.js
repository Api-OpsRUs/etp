var fs = require('fs');
var fp = require("lodash/fp");

// TODO: move to utils
function rgb(r, g, b){
    function c(d){
        var h = d.toString(16);        
        return h.length ===1 ? "0" + h : h;
    }

    return "#" + c(r) + c(g) + c(b);
}

module.exports = function ( topologyFile, outputFile, program ){

    var portdefs = require("./edge-port-defs.json");

    var topology = require( topologyFile );



//--- TODO: Refactor to utils.js -------------
    // TODO: refactor to utils: CREF: generateSvgDiagram
    // make lookup table for component:isApigee check
    var isApigee = fp(portdefs.mappings.edge).reduce( (comps, comp) => {
        comps[comp.client.component] = comp.client.apigee;
        return comps;
    }, {});


//------------------------------



    // Collect  Node List; ordered by Node ID
    var nodes = fp.flatMap( region => 
            fp.flatMap( subnet => 
                fp.map( node => {
                    node.roles = node.components;

                    node.dcid = region.id;

                    node.subnet = subnet.name;

                    return node;
                } )(subnet.nodes) 
            )(region.subnets)
        )(topology.regions);

    // Templates
    var versionT = fp.template( "<%= comment%> Planet: <%= planet %>; Version: <%= version %>. Generated by etp at: <%= genat %>" );


    var htmlDocHeader = `
<head>
    <style>
        html * {
            font-size: small;
            font-family: "Arial Narrow", Arial, sans-serif !important;
        }

        table {
            border-collapse: collapse;
        }

        th {
            background-color: #dddddd;
        }

        th,
        td {
            border: 1px solid lightgrey;
        }

        tr:nth-of-type(odd) {
            background-color: #f9f9f9;
        }
        .roleApigee {
            font-weight: bold;
            color: #f83100;
        }
        .role3rdParty {
            font-weight: bold;
            color: blue;s
        }
        .nodeID {
            font-weight: bold;
        }
    </style>
</head>`;

    var htmlInventoryHeader = `<table>\n
<thead>
    <tr>
        <th>DC</th>
        <th>Node #</th>
        <th>Role(s)</th>
        <th>Rack</th>
        <th>Subnet</th>
        <th>Hostname</th>
        <th>IP</th>
    </tr>
</thead>
<tbody>
`;

    var htmlInventoryFooter = "</tbody></table>\n\n"

    var htmlTDTemplate = fp.template( 
`<tr>
    <td>dc-<%= dcid %></td>
    <td>Node <bold><%= id %></bold></td>
    <td><%= roles %></td>
    <%= rackcell %>
    <td><%= subnet %></td>
    <td><%= hostname %></td>
    <td><%= ip %></td>
</tr>`);

    // https://s-media-cache-ak0.pinimg.com/564x/be/54/8f/be548f0f7eb1a29259a1e5c980b0d1e7.jpg
    var rackColor = {
        1: rgb( 21, 151, 2 ),
        2: rgb( 121, 235, 14 ),
        3: rgb( 198, 255, 72 ),
        4: rgb( 217, 255, 134 ),
        5: rgb( 164, 255, 84 ),
        6: rgb( 126, 239, 125 )
    }

    // http://img.bhs4.com/e1/8/e18d5f8ec497dc8baf51ca1d2462932e71d972ce_large.jpg
    var subnetColor = {
        1: rgb( 84, 87, 72 ),
        2: rgb( 180, 189, 131 ),
        3: rgb( 216, 208, 123 ),
        4: rgb( 242, 216, 109 ),
        5: rgb( 254, 196, 44 )
    }

    // Generate html table
    var htmlInventoryNodes = [];

    fp.reduce( (list, node) => {
        //console.log(node);
        list.push( htmlTDTemplate({
            dcid: node.dcid, 
            id: '<span class="nodeID">'+node.id+'</span>', 
            roles: fp.map( role => isApigee[role]?'<span class="roleApigee">'+role+'</span>':'<span class="role3rdParty">'+role+'</span>' )(node.roles).join(','), 
            rackcell: typeof node.rack === "undefined" ? '<td/>' : '<td style="text-align:right; background-color:'+rackColor[node.rack]+';">'+node.rack+'</td>', 
            subnet: node.subnet,
            hostname: node.hostname, 
            ip: node.ip}) );
        return list;
    }, htmlInventoryNodes)(fp.sortBy(["dcid","id"])(nodes));
    
    //



    //---------------------------------------
    var svgstream = fs.createWriteStream( outputFile );
    svgstream.write( htmlDocHeader );

    svgstream.write( htmlInventoryHeader );
    svgstream.write( htmlInventoryNodes.join('\n') );
    svgstream.write( htmlInventoryFooter );
    svgstream.end();

    //---------------------------------------
    

    // generate ansible file and ansible playbook invocation script

    // I.E.:
    // [edge]
    // n01 ansible_host=10.119.131.11 ansible_user=opapiadmin ansible_ssh_private_key_file=~/.ssh/id_ansible
    var ansibleHosts = [ "[edge]" ];

    var ansibleHostTemplate = fp.template( '<%= id %> ansible_host=<%= ip %><%= ansible_user %><%= ansible_key %>' );

    // function genRegionIdNodeId( onlySingleDC,  dcid, nodeid ){
    //     return onlySingleDC ? "n"+ fp.padCharsStart('0')(2)(nodeid) : "dc" + dcid + "n"+ fp.padCharsStart('0')(2)(nodeid);
    // }
    var genRegionIdNodeId = fp.curry( (onlySingleDC,  dcid, nodeid ) => {
        return onlySingleDC ? "n"+ fp.padCharsStart('0')(2)(nodeid) : "dc" + dcid + "n"+ fp.padCharsStart('0')(2)(nodeid);
    })
    var genNodeId = genRegionIdNodeId( topology.regions.length === 1 );

    fp.reduce( (list, node) => {
        //console.log(node);
        list.push( ansibleHostTemplate({
            id: genNodeId( node.dcid, node.id), 
            ip: node.ip,
            ansible_user: ((program.ansible_user || "") === "") ? "" : " ansible_user="+program.ansible_user,
            ansible_key: ((program.ansible_key || "") === "") ? "" : " ansible_ssh_private_key_file="+program.ansible_key
        }) );
        return list;
    }, ansibleHosts)(fp.sortBy(["dcid","id"])(nodes));   

    //-------------------------------------------------------------------------- 
    var svgstream = fs.createWriteStream( "hosts" );
    svgstream.write( ansibleHosts.join('\n') );
    svgstream.end();

    // TODO:
    // ansible top-level script

    //var edgeComponentInstallOrder = [ "ZK", "CS", "OL", "MS", "MP", "R", "PS", "QS" ];





    //-------------------------------------------------------------------------- 

    // TODO: 
    // silent .cfg file generation
/*
ZK can either be Voter [ZKv] or Observer [ZKo]. 

For 1 DC: 3 ZK nodes, all Voters.
For 2 DC : 3 ZK nodes in each DC, 3 [ZKv] in DC-1 and 2 [ZKv]+1 [ZKo] in DC-2.

Total number of [ZKv] across all DC's needs to be always odd. Number of [ZKo] nodes is not important, they are all read-only replicas. 

 CS ZK the relevant portions of the silent files for each DC in DU: 

My naming convention has $IPA* for DC-1, $IPB* for DC-2. 

 

DC-1: 
ZK_HOSTS="$IPA13 $IPA14 $IPA15 $IPB13 $IPB14 $IPB15:observer" 
ZK_CLIENT_HOSTS="$IPA13 $IPA14 $IPA15"
CASS_HOSTS="$IPA13:1,1 $IPA14:1,1 $IPA15:1,1 $IPB13:2,1 $IPB14:2,1 $IPB15:2,1"


DC-2: 
ZK_HOSTS="$IPB13 $IPB14 $IPB15:observer $IPA13 $IPA14 $IPA15" 
ZK_CLIENT_HOSTS="$IPB13 $IPB14 $IPB15"
CASS_HOSTS="$IPB13:2,1 $IPB14:2,1 $IPB15:2,1 $IPA13:1,1 $IPA14:1,1 $IPA15:1,1"

 C* syntax is IP:DC-number,Rack-number. 

NB first character is : second is , 

$IPB15:2,3   this would be the C* node in DC2 placed on the third rack of the DC.
*/

    // Generate .cfg per dc

 // collect nodes with CS comp in all DCs
    // var css = fp.filter(
    //     ["subnets"  tier", "dmz"] 
    //     // {subnets: {"tier":"dmz"} }
    //       //  { subnets: [ { nodes: [ "components", "R" ]}]}
    // )(topology.regions);
   //     )(topology.regions[0].subnets);
//  var cs1 = fp.map( ({id, components}) => {
//     console.log(id, components);
//  } )(topology.regions);

    var cfgT = fp.template( "<%= planetprefix %>dc<%= dcid %>.cfg" );

    var ndT = fp.template( "<%= nodeipref %> # <%= roles %>" );
    var ipT = fp.template( "IPDC<%= dcid %>N<%= nodeidref %>" );
    var drT = fp.template( "$<%= ipref %>:<%= dcid %>,<%= rackid %>" );

    function gatherComp( topology, comp ){
        var comps = [];
        fp.map(
            region => fp.map(
                subnet =>  
                    fp.reduce( (css, node) => {
                        // * to return for any component or "XX" component name to return for specific one
                        if( comp === "*" || fp.includes( comp )(node.components) ){
                            var c = { 
                                dcid: region.id, 
                                nodeid: node.id, 
                                rackid: (typeof node.rack === "undefined"? 1 : node.rack), 
                                ip: node.ip
                            };
                            c.nodeidref = fp.padCharsStart('0')(2)(c.nodeid);

                            c.regionidnodeidref = genNodeId( c.dcid, c.nodeid );

                            c.ipref = ipT({ dcid: c.dcid, nodeidref: c.nodeidref });
                            c.drref = drT({ ipref: c.ipref, dcid: c.dcid, rackid: c.rackid } );

                            c.roles = node.components.join(", ");

                            c.nodeipref = ndT({ nodeipref: fp.padCharsEnd(' ')(34)( c.ipref + "=" + c.ip ), roles: c.roles });
                            comps.push( c );
                        }
                        return comps;
                    }, comps )(subnet.nodes)
            )(region.subnets)
        )(topology.regions);

        return fp.sortBy(["dcid","nodeid"])(comps);
    }

    var all = gatherComp(topology, "*");

    var css = gatherComp(topology, "CS");
    var zks = gatherComp(topology, "CS");
    

    // Generate .cfg CS/ZK fragments
    if( program.prefix ){
        fp.map( region => {
            // top-level iteration by region/DC

            var cfgstream = fs.createWriteStream( cfgT({planetprefix: program.prefix, dcid: region.id }) );


            cfgstream.write( versionT({ comment: '#', planet: topology.planet, version: topology.version, genat: new Date() } ));
            cfgstream.write("\n\n");


            // list nodes
            fp.toPairs(fp.groupBy("dcid")(all)).map(
                dc => {
                    cfgstream.write( "#--------------------------------------------------------------------------\n");
                    cfgstream.write( "# Datacentre: " + dc[0] + "\n" );
                    cfgstream.write( "#--------------------------------------------------------------------------\n");
                    cfgstream.write(dc[1].map(n=>n.nodeipref).join('\n'));
                    cfgstream.write("\n\n");
            })
            cfgstream.write("");
        
            var observers = (zks.length % 2)===0 ? 1: 2

            var _zks = fp(zks).take(zks.length-observers).map(n=> ({dcid: n.dcid, zkref: "$"+n.ipref}) ).value().concat(
                            fp(zks).takeRight(observers).map(n=> ({ dcid: n.dcid, zkref: "$"+n.ipref + ":observer" }) ).value()
                        );

            var ZK_HOSTS = fp(_zks).filter({dcid: region.id}).map(n=>n.zkref).concat(
                fp(_zks).reject({dcid: region.id}).map(n=>n.zkref) ).value().join(" ");


            var ZK_CLIENT_HOSTS = fp(zks).filter({dcid: region.id}).map(n=> "$"+n.ipref).value().join(" ") 

            var CASS_HOSTS = fp(css).filter({dcid: region.id}).map(n=>n.drref).value().join(" ") 
                        + " " + fp(css).reject({dcid: region.id}).map(n=>n.drref).value().join(" ");

            cfgstream.write( "-------------\n")
            cfgstream.write( "ZK_HOSTS=\""+ZK_HOSTS+"\"\n" );
            cfgstream.write( "ZK_CLIENT_HOSTS=\""+ZK_CLIENT_HOSTS+"\"\n" );
            cfgstream.write( "CASS_HOSTS=\""+CASS_HOSTS+"\"\n" );


            // TODO: LDAP

    /*------------------------
    LDAP properties affected are:

    USE_LDAP_REMOTE_HOST=y
    LDAP_HOST=
    APIGEE_LDAPPW=
    LDAP_PORT=
    for multi DC: LDAP_TYPE=2; if standalone, i..e no replication needed: LDAP_TYPE=1

    LDAP_SID=1,2,3 etc for the ID of each node in sequence
    LDAP_PEER=

    for up to 2 LDAP nodes LDAP_PEER point to each other. For more I have the logic. Limit to 2 LDAP peers for now in your logic

    for total  >2 nodes is LDAP multimaster replication across 3 or more nodes.

    */

        //-------------------
            // TODO: PG/PGm/PGs



            cfgstream.end();

        })(topology.regions)
    }
    // end: program.prefix




    //-------------------------------------------------------------------------- 
    // TODO:
    // ansible top-level script

    if( program.ansible_script ){
        var ansiblestream = fs.createWriteStream( program.ansible_script );

        var ansibleT = fp.template( 'ansible-playbook -l <%= regionidnodeidref %> $OPS_HOME/edge-comp-setup.yml -e "COMP=<%= comp %> CFG=<%= cfg %>"' );

        fp.map( region => {
            var cfgfile = cfgT({planetprefix: program.prefix, dcid: region.id });

            fp.map( comp =>
                
                ansiblestream.write(
                    fp.map(
                        n => ansibleT({ regionidnodeidref: n.regionidnodeidref, comp: comp.toLowerCase(), cfg: cfgfile })
                    )( fp.filter({dcid: region.id} )(gatherComp(topology, comp )) ).join('\n') +
                    "\n\n"
                )
            )(portdefs.edgecomponentinstallsequence)
        })(topology.regions);

        ansiblestream.end();
        //-------------------------------------------------------------------------- 
    }



};

